SJF and FIFO

Spezzare simulazione dalla specifica del problema, richiede la sua sintassi.
Generare temi d'esame!

Estrai il fattore comune a tutti gli scheduler e sgancia lo scheduler dal LaTeX e dalla definizione del problema.

Ogni algoritmo nella sua folder, e coi suoi test.
Crea una libtest nel folder che lancia in automatico i vari test, che fanno girare il loop di eventi e controllano che i dati di simulazione siano coerenti con snapshot salvati.
Lancia con "bun test" che cerca tutte le librerie di test e va!
Puoi fare "bun -u" per aggiornare gli snapshot di test.

Creare un nuovo scheduler:
- immagina il formato di dati in ingresso, che strutture dati assegnare ad ogni task, dividile per user-defined e background variables che usa lo scheduler.
- identifica gli eventi da considerare per lo scheduler, il formalismo é una lista di numeri che dice quanto deve girare e quanto deve sleepare ogni processo. La lista viene interpreata alternando "sleep" "run" e via. Ricicla questo formalismo per i nuovi scheduler. Parti implementando solo "durata" del processo, poi aggiungi la lista run-sleep-run-sleep.
- La lista above definisce durante l'esistenza del programma le sezioni di tempo che dedica e runnare e a sleepare.
IMPORTANTE -> la libreria deve esportare un produceSchedule. L'event loop governa lo scheduler, e quello che conta é il SimData, che viene poi transformato in LaTeX. Possiamo simulare come vogliamo finché esportiamo nel formato comune di SimSchedule che le altre librerie possono interpretare per stampare il LaTeX.
- Campi importanti di SimSchedule:
 - timeline, per ogni task ed instante di tempo dici in che stato é la task. Lista di TaskSlots!
 - TaskSlots.event é sta girando o in attesa, in belowSlot lo scheduler puó scrivere quello che vuole per chiarire cosa succede (annotazione). Hai anche aboveSlot sempre per annotare.

Realizza "simulate FIFO" e "simulate SJF". Crea casi d'esempio e rendili dumpabili con "dump". (Riusa I dump come test, tanto vale :) )

Sempre per usarlo per gli esami, é possibile dumpare non solo lo schedule completo, ma anche omettendo dei pezzi per renderlo un esercizio. (guarda temi d'esami per decidere come fare)

Figo:
- | tikz2pdf --open, con questa pipe apri direttamente quello che esce. Dopo export.
- export blank, esporta lo spazio bianco per gli esercizi.
- export data, esporta i dati dell'esercizio, da un'unica fonte di veritá.

Se possiamo riciclare qualcosa tra i due simulatori dei due scheduler, fallo!
Idealmente crea un'architettura SW per easy integration dei due simulatori (uno per algoritmo, poi integrati).

usa le strutture dati per integrazione con export e via. Dentro il tuo simulatore puoi creare le strutture dati che ti pare, tienile consistenti come naming.

References da wikipedia e via sono forse fin troppo.
Buona base di test, anche se non estensiva. (Almeno stesso numero che altrove, ogni volta che crei un BUG, scrivi il test per controllare che non si ripresenti)

Timer: limita la lunghezza della simulazione per evitare che il CSS esploda, il grafico basta che funzioni per certe lunghezze fissate di Timer (non permettere variazione infinita, ma discreta). Il timer é la larghezza del grafico, se il delta temporale é arbitrario diventa merda, permetti solo quanti discreti nel sensato. Sempre 0.5ms va bene.
Ogni volta che scade il timer viene rifatto lo scheduling.

=> granularitá della simulazione, non continua, ma con valori comodi per portare avanti la simulazione. Lavora con istanti di tempo discreti, e ogni volta che scade il timer runna lo scheduler.
Se hai problemi col timer riportaglieli.